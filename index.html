<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Kleisli by txus</title>
    <!-- start Mixpanel --><script type="text/javascript">(function(f,b){if(!b.__SV){var a,e,i,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");
      for(g=0;g<i.length;g++)f(c,i[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);
        mixpanel.init("af522f005afba4a9815d19dc53e50261");</script><!-- end Mixpanel -->
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Kleisli</h1>
          <h2>Usable, idiomatic common monads in Ruby</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/txus/kleisli/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/txus/kleisli/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/txus/kleisli" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a id="kleisli-" class="anchor" href="#kleisli-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kleisli <a href="http://travis-ci.org/txus/adts"><img src="https://secure.travis-ci.org/txus/adts.png" alt="Build Status"></a>
</h1>

<p>An idiomatic, clean implementation of a few common useful monads in Ruby,
written by <a href="https://github.com/rylev">Ryan Levick</a> and me.</p>

<p>It aims to be idiomatic Ruby to use in Enter-Prise production apps, not a proof
of concept.</p>

<p>In your Gemfile:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">gem</span> <span class="pl-s1"><span class="pl-pds">'</span>kleisli<span class="pl-pds">'</span></span></pre></div>

<p>We would like to thank Curry and Howard for their correspondence.</p>

<h2>
<a id="notation" class="anchor" href="#notation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notation</h2>

<p>For all its monads, Kleisli implements <code>return</code> (we call it <code>lift</code> instead, as
<code>return</code> is a reserved keyword in Ruby) with convenience global methods (see
which for each monad below).</p>

<p>Kleisli uses a clever Ruby syntax trick to implement the <code>bind</code> operator, which
looks like this: <code>&gt;-&gt;</code> when used with a block. We will probably burn in hell
for this. You can also use <code>&gt;</code> or <code>&gt;&gt;</code> if you're going to pass in a proc or
  lambda object.</p>

<h3>
<a id="function-composition" class="anchor" href="#function-composition" aria-hidden="true"><span class="octicon octicon-link"></span></a>Function composition</h3>

<p>You can use Haskell-like function composition with F and the familiar <code>.</code>. This
is such a perversion of Ruby syntax that Matz would probably condemn this:</p>

<p>Think of <code>F</code> as the identity function. Although it's just a hack to make it
work in Ruby.</p>

<div class="highlight highlight-ruby"><pre><span class="pl-c"># Reminder that (f . g) x= f(g(x))</span>
f <span class="pl-k">=</span> <span class="pl-vo">F</span> . first . last
f.call [[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>], [<span class="pl-c1">3</span>,<span class="pl-c1">4</span>]]
<span class="pl-c"># =&gt; 3</span>

f <span class="pl-k">=</span> <span class="pl-vo">F</span> . capitalize . reverse
f.call <span class="pl-s1"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>
<span class="pl-c"># =&gt; "Olleh"</span></pre></div>

<p>Functions and methods are interchangeable:</p>

<div class="highlight highlight-ruby"><pre>foo <span class="pl-k">=</span> lambda { |<span class="pl-vo">s</span>| s.reverse }

f <span class="pl-k">=</span> <span class="pl-vo">F</span> . capitalize . fn(<span class="pl-k">&amp;</span>foo)
f.call <span class="pl-s1"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>
<span class="pl-c"># =&gt; "Olleh"</span></pre></div>

<p>All functions and methods are partially applicable:</p>

<div class="highlight highlight-ruby"><pre>
<span class="pl-c"># Partially applied method:</span>
f <span class="pl-k">=</span> <span class="pl-vo">F</span> . split(<span class="pl-s1"><span class="pl-pds">"</span>:<span class="pl-pds">"</span></span>) . strip
f.call <span class="pl-s1"><span class="pl-pds">"</span>  localhost:9092     <span class="pl-pds">"</span></span>
<span class="pl-c"># =&gt; ["localhost", "9092"]</span>

<span class="pl-c"># Partially applied lambda:</span>
my_split <span class="pl-k">=</span> lambda { |<span class="pl-vo">str</span>, *<span class="pl-vo">args</span>| str.split(<span class="pl-k">*</span>args) }
f <span class="pl-k">=</span> <span class="pl-vo">F</span> . fn(<span class="pl-s1"><span class="pl-pds">"</span>:<span class="pl-pds">"</span></span>, <span class="pl-k">&amp;</span>split)
f.call <span class="pl-s1"><span class="pl-pds">"</span>  localhost:9092     <span class="pl-pds">"</span></span>
<span class="pl-c"># =&gt; ["localhost", "9092"]</span></pre></div>

<p>Finally, for convenience, <code>F</code> is the identity function:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-s3">F</span>.call(<span class="pl-c1">1</span>) <span class="pl-c"># =&gt; 1</span></pre></div>

<h2>
<a id="maybe-monad" class="anchor" href="#maybe-monad" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maybe monad</h2>

<p>The Maybe monad is useful to express a pipeline of computations that might
return nil at any point. <code>user.address.street</code> anyone?</p>

<h3>
<a id="--bind" class="anchor" href="#--bind" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>&gt;-&gt;</code> (bind)</h3>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

maybe_user <span class="pl-k">=</span> <span class="pl-vo">Maybe</span>(user) <span class="pl-k">&gt;</span><span class="pl-k">-</span><span class="pl-k">&gt;</span> user {
  <span class="pl-vo">Maybe</span>(user.address) } <span class="pl-k">&gt;</span><span class="pl-k">-</span><span class="pl-k">&gt;</span> address {
    <span class="pl-vo">Maybe</span>(address.street) }

<span class="pl-c"># If user exists</span>
<span class="pl-c"># =&gt; Some("Monad Street")</span>
<span class="pl-c"># If user is nil</span>
<span class="pl-c"># =&gt; None()</span>

<span class="pl-c"># You can also use Some and None as type constructors yourself.</span>
x <span class="pl-k">=</span> <span class="pl-vo">Some</span>(<span class="pl-c1">10</span>)
y <span class="pl-k">=</span> <span class="pl-vo">None</span>()
</pre></div>

<p>As usual (with Maybe and Either), using point-free style is much cleaner:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-vo">Maybe</span>(user) <span class="pl-k">&gt;&gt;</span> <span class="pl-vo">F</span> . fn(<span class="pl-k">&amp;</span><span class="pl-vo">Maybe</span>) . address <span class="pl-k">&gt;&gt;</span> <span class="pl-vo">F</span> . fn(<span class="pl-k">&amp;</span><span class="pl-vo">Maybe</span>) . street</pre></div>

<h3>
<a id="fmap" class="anchor" href="#fmap" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fmap</code>
</h3>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

<span class="pl-c"># If we know that a user always has an address with a street</span>
<span class="pl-vo">Maybe</span>(user).fmap(<span class="pl-k">&amp;</span><span class="pl-c1">:address</span>).fmap(<span class="pl-k">&amp;</span><span class="pl-c1">:street</span>)

<span class="pl-c"># If the user exists</span>
<span class="pl-c"># =&gt; Some("Monad Street")</span>
<span class="pl-c"># If the user is nil</span>
<span class="pl-c"># =&gt; None()</span></pre></div>

<h2>
<a id="try" class="anchor" href="#try" aria-hidden="true"><span class="octicon octicon-link"></span></a>Try</h2>

<p>The Try monad is useful to express a pipeline of computations that might throw
an exception at any point.</p>

<h3>
<a id="--bind-1" class="anchor" href="#--bind-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>&gt;-&gt;</code> (bind)</h3>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

json_string <span class="pl-k">=</span> get_json_from_somewhere

result <span class="pl-k">=</span> <span class="pl-vo">Try</span> { <span class="pl-s3">JSON</span>.parse(json_string) } <span class="pl-k">&gt;</span><span class="pl-k">-</span><span class="pl-k">&gt;</span> json {
  <span class="pl-vo">Try</span> { json[<span class="pl-s1"><span class="pl-pds">"</span>dividend<span class="pl-pds">"</span></span>].to_i <span class="pl-k">/</span> json[<span class="pl-s1"><span class="pl-pds">"</span>divisor<span class="pl-pds">"</span></span>].to_i }
}

<span class="pl-c"># If no exception was thrown:</span>

result       <span class="pl-c"># =&gt; #&lt;Try::Success @value=123&gt;</span>
result.value <span class="pl-c"># =&gt; 123</span>

<span class="pl-c"># If there was a ZeroDivisionError exception for example:</span>

result           <span class="pl-c"># =&gt; #&lt;Try::Failure @exception=#&lt;ZeroDivisionError ...&gt;&gt;</span>
result.exception <span class="pl-c"># =&gt; #&lt;ZeroDivisionError ...&gt;</span></pre></div>

<h3>
<a id="fmap-1" class="anchor" href="#fmap-1" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fmap</code>
</h3>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

<span class="pl-vo">Try</span> { <span class="pl-s3">JSON</span>.parse(json_string) }.fmap(<span class="pl-k">&amp;</span><span class="pl-c1">:symbolize_keys</span>).value

<span class="pl-c"># If everything went well:</span>
<span class="pl-c"># =&gt; { :my =&gt; "json", :with =&gt; "symbolized keys" }</span>
<span class="pl-c"># If an exception was thrown:</span>
<span class="pl-c"># =&gt; nil</span></pre></div>

<h3>
<a id="to_maybe" class="anchor" href="#to_maybe" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>to_maybe</code>
</h3>

<p>Sometimes it's useful to interleave both <code>Try</code> and <code>Maybe</code>. To convert a <code>Try</code>
into a <code>Maybe</code> you can use <code>to_maybe</code>:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

<span class="pl-vo">Try</span> { <span class="pl-s3">JSON</span>.parse(json_string) }.fmap(<span class="pl-k">&amp;</span><span class="pl-c1">:symbolize_keys</span>).to_maybe

<span class="pl-c"># If everything went well:</span>
<span class="pl-c"># =&gt; Some({ :my =&gt; "json", :with =&gt; "symbolized keys" })</span>
<span class="pl-c"># If an exception was thrown:</span>
<span class="pl-c"># =&gt; None()</span></pre></div>

<h2>
<a id="either" class="anchor" href="#either" aria-hidden="true"><span class="octicon octicon-link"></span></a>Either</h2>

<p>The Either monad is useful to express a pipeline of computations that might return an error object with some information.</p>

<p>It has two type constructors: <code>Right</code> and <code>Left</code>. As a useful mnemonic, <code>Right</code> is for when everything went "right" and <code>Left</code> is used for errors.</p>

<p>Think of it as exceptions without messing with the call stack.</p>

<h3>
<a id="--bind-2" class="anchor" href="#--bind-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>&gt;-&gt;</code> (bind)</h3>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

result <span class="pl-k">=</span> <span class="pl-vo">Right</span>(<span class="pl-c1">3</span>) <span class="pl-k">&gt;</span><span class="pl-k">-</span><span class="pl-k">&gt;</span> value {
  <span class="pl-k">if</span> value <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>
    <span class="pl-vo">Right</span>(value <span class="pl-k">+</span> <span class="pl-c1">3</span>)
  <span class="pl-k">else</span>
    <span class="pl-vo">Left</span>(<span class="pl-s1"><span class="pl-pds">"</span>value was less or equal than 1<span class="pl-pds">"</span></span>)
  <span class="pl-k">end</span>
} <span class="pl-k">&gt;</span><span class="pl-k">-</span><span class="pl-k">&gt;</span> value {
  <span class="pl-k">if</span> value <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
    <span class="pl-vo">Right</span>(value <span class="pl-k">*</span> <span class="pl-c1">2</span>)
  <span class="pl-k">else</span>
    <span class="pl-vo">Left</span>(<span class="pl-s1"><span class="pl-pds">"</span>value was not even<span class="pl-pds">"</span></span>)
  <span class="pl-k">end</span>
}

<span class="pl-c"># If everything went well</span>
result <span class="pl-c"># =&gt; Right(12)</span>
result.value <span class="pl-c"># =&gt; 12</span>

<span class="pl-c"># If it failed in the first block</span>
result <span class="pl-c"># =&gt; Left("value was less or equal than 1")</span>
result.value <span class="pl-c"># =&gt; "value was less or equal than 1"</span>

<span class="pl-c"># If it failed in the second block</span>
result <span class="pl-c"># =&gt; Left("value was not even")</span>
result.value <span class="pl-c"># =&gt; "value was not even"</span>

<span class="pl-c"># Point-free style bind!</span>
result <span class="pl-k">=</span> <span class="pl-vo">Right</span>(<span class="pl-c1">3</span>) <span class="pl-k">&gt;&gt;</span> <span class="pl-vo">F</span> . fn(<span class="pl-k">&amp;</span><span class="pl-vo">Right</span>) . <span class="pl-k">*</span>(<span class="pl-c1">2</span>)
result <span class="pl-c"># =&gt; Right(6)</span>
result.value <span class="pl-c"># =&gt; 6</span></pre></div>

<h3>
<a id="fmap-2" class="anchor" href="#fmap-2" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fmap</code>
</h3>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

result <span class="pl-k">=</span> <span class="pl-k">if</span> foo <span class="pl-k">&gt;</span> bar
  <span class="pl-vo">Right</span>(<span class="pl-c1">10</span>)
<span class="pl-k">else</span>
  <span class="pl-vo">Left</span>(<span class="pl-s1"><span class="pl-pds">"</span>wrong<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>.fmap { |<span class="pl-vo">x</span>| x <span class="pl-k">*</span> <span class="pl-c1">2</span> }

<span class="pl-c"># If everything went well</span>
result <span class="pl-c"># =&gt; Right(20)</span>
<span class="pl-c"># If it didn't</span>
result <span class="pl-c"># =&gt; Left("wrong")</span></pre></div>

<h3>
<a id="or" class="anchor" href="#or" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>or</code>
</h3>

<p><code>or</code> does pretty much what would you expect:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">'</span>kleisli<span class="pl-pds">'</span></span>

<span class="pl-vo">Right</span>(<span class="pl-c1">10</span>).<span class="pl-k">or</span>(<span class="pl-vo">Right</span>(<span class="pl-c1">999</span>)) <span class="pl-c"># =&gt; Right(10)</span>
<span class="pl-vo">Left</span>(<span class="pl-s1"><span class="pl-pds">"</span>error<span class="pl-pds">"</span></span>).<span class="pl-k">or</span>(<span class="pl-vo">Left</span>(<span class="pl-s1"><span class="pl-pds">"</span>new error<span class="pl-pds">"</span></span>)) <span class="pl-c"># =&gt; Left("new error")</span>
<span class="pl-vo">Left</span>(<span class="pl-s1"><span class="pl-pds">"</span>error<span class="pl-pds">"</span></span>).<span class="pl-k">or</span> { |<span class="pl-vo">err</span>| <span class="pl-vo">Left</span>(<span class="pl-s1"><span class="pl-pds">"</span>new <span class="pl-pse">#{</span><span class="pl-s2">err</span><span class="pl-pse"><span class="pl-s2">}</span></span><span class="pl-pds">"</span></span>) } <span class="pl-c"># =&gt; Left("new error")</span></pre></div>

<h3>
<a id="to_maybe-1" class="anchor" href="#to_maybe-1" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>to_maybe</code>
</h3>

<p>Sometimes it's useful to turn an <code>Either</code> into a <code>Maybe</code>. You can use
<code>to_maybe</code> for that:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

result <span class="pl-k">=</span> <span class="pl-k">if</span> foo <span class="pl-k">&gt;</span> bar
  <span class="pl-vo">Right</span>(<span class="pl-c1">10</span>)
<span class="pl-k">else</span>
  <span class="pl-vo">Left</span>(<span class="pl-s1"><span class="pl-pds">"</span>wrong<span class="pl-pds">"</span></span>)
<span class="pl-k">end</span>.to_maybe

<span class="pl-c"># If everything went well:</span>
result <span class="pl-c"># =&gt; Some(10)</span>
<span class="pl-c"># If it didn't</span>
result <span class="pl-c"># =&gt; None()</span></pre></div>

<h2>
<a id="writer" class="anchor" href="#writer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Writer</h2>

<p>The Writer monad is arguably the least useful monad in Ruby (as side effects
are uncontrolled), but let's take a look at it anyway.</p>

<p>It is used to model computations that <em>append</em> to some kind of state (which
needs to be a Monoid, expressed in the <code>Kleisli::Monoid</code> mixin) at each step.</p>

<p>(We've already implemented the Monoid interface for <code>String</code>, <code>Array</code>, <code>Hash</code>,
<code>Fixnum</code> and <code>Float</code> for you.)</p>

<p>An example would be a pipeline of computations that append to a log, for
example a list of strings.</p>

<h3>
<a id="--bind-3" class="anchor" href="#--bind-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>&gt;-&gt;</code> (bind)</h3>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

writer <span class="pl-k">=</span> <span class="pl-vo">Writer</span>([], <span class="pl-c1">100</span>) <span class="pl-k">&gt;</span><span class="pl-k">-</span><span class="pl-k">&gt;</span> value {
  <span class="pl-vo">Writer</span>([<span class="pl-s1"><span class="pl-pds">"</span>added 100<span class="pl-pds">"</span></span>], value <span class="pl-k">+</span> <span class="pl-c1">100</span>)
} <span class="pl-k">&gt;</span><span class="pl-k">-</span><span class="pl-k">&gt;</span> value {
  <span class="pl-vo">Writer</span>([<span class="pl-s1"><span class="pl-pds">"</span>added 140 more<span class="pl-pds">"</span></span>], value <span class="pl-k">+</span> <span class="pl-c1">140</span>)
} <span class="pl-c"># =&gt; Writer(["added 100", "added 140 more"], 340)</span>

log, value <span class="pl-k">=</span> writer.unwrap
log <span class="pl-c"># =&gt; ["added 100", "added 140 more"]</span>
value <span class="pl-c"># =&gt; 340</span></pre></div>

<h3>
<a id="fmap-3" class="anchor" href="#fmap-3" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fmap</code>
</h3>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

writer <span class="pl-k">=</span> <span class="pl-vo">Writer</span>([], <span class="pl-c1">100</span>).fmap { |<span class="pl-vo">value</span>|
  value <span class="pl-k">+</span> <span class="pl-c1">100</span>
} <span class="pl-c"># =&gt; Writer([], 200)</span></pre></div>

<h2>
<a id="future" class="anchor" href="#future" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future</h2>

<p>The Future monad models a pipeline of computations that will happen in the future, as soon as the value needed for each step is available. It is useful to model, for example, a sequential chain of HTTP calls.</p>

<p>There's a catch unfortunately -- values passed to the functions are wrapped in
lambdas, so you need to call <code>.call</code> on them. See the examples below.</p>

<h3>
<a id="--bind-4" class="anchor" href="#--bind-4" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>&gt;-&gt;</code> (bind)</h3>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

f <span class="pl-k">=</span> <span class="pl-vo">Future</span>(<span class="pl-s1"><span class="pl-pds">"</span>myendpoint.com<span class="pl-pds">"</span></span>) <span class="pl-k">&gt;</span><span class="pl-k">-</span><span class="pl-k">&gt;</span> url {
  <span class="pl-vo">Future</span> { <span class="pl-s3">HTTP</span>.get(url.call) }
} <span class="pl-k">&gt;</span><span class="pl-k">-</span><span class="pl-k">&gt;</span> response {
  <span class="pl-vo">Future</span> {
    other_url <span class="pl-k">=</span> <span class="pl-s3">JSON</span>.parse(response.call.body)[<span class="pl-c1">:other_url</span>]
    <span class="pl-s3">HTTP</span>.get(other_url)
  }
} <span class="pl-k">&gt;</span><span class="pl-k">-</span><span class="pl-k">&gt;</span> other_response {
  <span class="pl-vo">Future</span> { <span class="pl-s3">JSON</span>.parse(other_response.call.body) }
}

<span class="pl-c"># Do some other stuff...</span>

f.await <span class="pl-c"># =&gt; block until the whole pipeline is realized</span>
<span class="pl-c"># =&gt; { "my" =&gt; "response body" }</span></pre></div>

<h3>
<a id="fmap-4" class="anchor" href="#fmap-4" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fmap</code>
</h3>

<div class="highlight highlight-ruby"><pre><span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">"</span>kleisli<span class="pl-pds">"</span></span>

<span class="pl-vo">Future</span> { expensive_operation }.fmap { |<span class="pl-vo">x</span>| x <span class="pl-k">*</span> <span class="pl-c1">2</span> }.await
<span class="pl-c"># =&gt; result of expensive_operation * 2</span></pre></div>

<h2>
<a id="whos-this" class="anchor" href="#whos-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>Who's this</h2>

<p>This was made by <a href="http://blog.txus.io">Josep M. Bach (Txus)</a> and <a href="https://github.com/rylev">Ryan
Levick</a> under the MIT license. We are <a href="https://twitter.com/txustice">@txustice</a> and
<a href="https://twitter.com/itchyankles">@itchyankles</a> on twitter (where you should probably follow us!).</p>
        </section>

        <footer>
          Kleisli is maintained by <a href="https://github.com/txus">txus</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>


      </div>
    </div>
  </body>
</html>
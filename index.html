<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Kleisli by txus</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Kleisli</h1>
          <h2>Usable, idiomatic common monads in Ruby</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/txus/kleisli/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/txus/kleisli/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/txus/kleisli" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a id="kleisli-" class="anchor" href="#kleisli-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kleisli <a href="http://travis-ci.org/txus/adts"><img src="https://secure.travis-ci.org/txus/adts.png" alt="Build Status"></a>
</h1>

<p>An idiomatic, clean implementation of a few common useful monads in Ruby,
written by <a href="https://github.com/rylev">Ryan Levick</a> and me.</p>

<p>It aims to be idiomatic Ruby to use in Enter-Prise production apps, not a proof
of concept.</p>

<p>In your Gemfile:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">gem</span> <span class="s1">'kleisli'</span></pre></div>

<p>We would like to thank Curry and Howard for their correspondence.</p>

<h2>
<a id="notation" class="anchor" href="#notation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notation</h2>

<p>For all its monads, Kleisli implements <code>return</code> (we call it <code>lift</code> instead, as
<code>return</code> is a reserved keyword in Ruby) with convenience global methods (see
which for each monad below).</p>

<p>Kleisli uses a clever Ruby syntax trick to implement the <code>bind</code> operator, which
looks like this: <code>&gt;-&gt;</code> when used with a block. We will probably burn in hell
for this. You can also use <code>&gt;</code> or <code>&gt;&gt;</code> if you're going to pass in a proc or
  lambda object.</p>

<h3>
<a id="function-composition" class="anchor" href="#function-composition" aria-hidden="true"><span class="octicon octicon-link"></span></a>Function composition</h3>

<p>You can use Haskell-like function composition with F and the familiar <code>.</code>. This
is such a perversion of Ruby syntax that Matz would probably condemn this:</p>

<p>Think of <code>F</code> as the identity function. Although it's just a hack to make it
work in Ruby.</p>

<div class="highlight highlight-ruby"><pre><span class="c1"># Reminder that (f . g) x= f(g(x))</span>
f <span class="o">=</span> <span class="no">F</span> . first . last
f.call <span class="o">[[</span><span class="m">1</span>,<span class="m">2</span><span class="o">]</span>, <span class="o">[</span><span class="m">3</span>,<span class="m">4</span><span class="o">]]</span>
<span class="c1"># =&gt; 3</span>

f <span class="o">=</span> <span class="no">F</span> . capitalize . reverse
f.call <span class="s2">"hello"</span>
<span class="c1"># =&gt; "Olleh"</span></pre></div>

<p>Functions and methods are interchangeable:</p>

<div class="highlight highlight-ruby"><pre><span class="k">def</span> <span class="nf">foo</span>(<span class="nv">s</span>)
  s.reverse
<span class="k">end</span>

f <span class="o">=</span> <span class="no">F</span> . capitalize . foo
f.call <span class="s2">"hello"</span>
<span class="c1"># =&gt; "Olleh"</span></pre></div>

<p>All functions and methods are partially applicable:</p>

<div class="highlight highlight-ruby"><pre>
f <span class="o">=</span> <span class="no">F</span> . split(<span class="s2">":"</span>) . strip
puts f.call <span class="s2">"  localhost:9092     "</span>
<span class="c1"># =&gt; ["localhost", "9092"]</span></pre></div>

<h2>
<a id="maybe-monad" class="anchor" href="#maybe-monad" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maybe monad</h2>

<p>The Maybe monad is useful to express a pipeline of computations that might
return nil at any point. <code>user.address.street</code> anyone?</p>

<h3>
<a id="--bind" class="anchor" href="#--bind" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>&gt;-&gt;</code> (bind)</h3>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

maybe_user <span class="o">=</span> <span class="no">Maybe</span>(user) <span class="o">&gt;</span><span class="o">-</span><span class="o">&gt;</span> user {
  <span class="no">Maybe</span>(user.address) } <span class="o">&gt;</span><span class="o">-</span><span class="o">&gt;</span> address {
    <span class="no">Maybe</span>(address.street) }

<span class="c1"># If user exists</span>
<span class="c1"># =&gt; Some("Monad Street")</span>
<span class="c1"># If user is nil</span>
<span class="c1"># =&gt; None()</span>

<span class="c1"># You can also use Some and None as type constructors yourself.</span>
x <span class="o">=</span> <span class="no">Some</span>(<span class="m">10</span>)
y <span class="o">=</span> <span class="no">None</span>()

<span class="c1"># Now using fancy point-free style:</span>
<span class="no">Maybe</span>(user) <span class="o">&gt;&gt;</span> <span class="no">F</span> . <span class="no">Maybe</span> . address <span class="o">&gt;&gt;</span> <span class="no">F</span> . <span class="no">Maybe</span> . street</pre></div>

<h3>
<a id="fmap" class="anchor" href="#fmap" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fmap</code>
</h3>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

<span class="c1"># If we know that a user always has an address with a street</span>
<span class="no">Maybe</span>(user).fmap(<span class="o">&amp;</span><span class="ss">:address</span>).fmap(<span class="o">&amp;</span><span class="ss">:street</span>)

<span class="c1"># If the user exists</span>
<span class="c1"># =&gt; Some("Monad Street")</span>
<span class="c1"># If the user is nil</span>
<span class="c1"># =&gt; None()</span></pre></div>

<h2>
<a id="try" class="anchor" href="#try" aria-hidden="true"><span class="octicon octicon-link"></span></a>Try</h2>

<p>The Try monad is useful to express a pipeline of computations that might throw
an exception at any point.</p>

<h3>
<a id="--bind-1" class="anchor" href="#--bind-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>&gt;-&gt;</code> (bind)</h3>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

json_string <span class="o">=</span> get_json_from_somewhere

result <span class="o">=</span> <span class="no">Try</span> { <span class="no">JSON</span>.parse(json_string) } <span class="o">&gt;</span><span class="o">-</span><span class="o">&gt;</span> json {
  <span class="no">Try</span> { json<span class="o">[</span><span class="s2">"dividend"</span><span class="o">]</span>.to_i <span class="o">/</span> json<span class="o">[</span><span class="s2">"divisor"</span><span class="o">]</span>.to_i }
}

<span class="c1"># If no exception was thrown:</span>

result       <span class="c1"># =&gt; #&lt;Try::Success @value=123&gt;</span>
result.value <span class="c1"># =&gt; 123</span>

<span class="c1"># If there was a ZeroDivisionError exception for example:</span>

result           <span class="c1"># =&gt; #&lt;Try::Failure @exception=#&lt;ZeroDivisionError ...&gt;&gt;</span>
result.exception <span class="c1"># =&gt; #&lt;ZeroDivisionError ...&gt;</span></pre></div>

<h3>
<a id="fmap-1" class="anchor" href="#fmap-1" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fmap</code>
</h3>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

<span class="no">Try</span> { <span class="no">JSON</span>.parse(json_string) }.fmap(<span class="o">&amp;</span><span class="ss">:symbolize_keys</span>).value

<span class="c1"># If everything went well:</span>
<span class="c1"># =&gt; { :my =&gt; "json", :with =&gt; "symbolized keys" }</span>
<span class="c1"># If an exception was thrown:</span>
<span class="c1"># =&gt; nil</span></pre></div>

<h3>
<a id="to_maybe" class="anchor" href="#to_maybe" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>to_maybe</code>
</h3>

<p>Sometimes it's useful to interleave both <code>Try</code> and <code>Maybe</code>. To convert a <code>Try</code>
into a <code>Maybe</code> you can use <code>to_maybe</code>:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

<span class="no">Try</span> { <span class="no">JSON</span>.parse(json_string) }.fmap(<span class="o">&amp;</span><span class="ss">:symbolize_keys</span>).to_maybe

<span class="c1"># If everything went well:</span>
<span class="c1"># =&gt; Some({ :my =&gt; "json", :with =&gt; "symbolized keys" })</span>
<span class="c1"># If an exception was thrown:</span>
<span class="c1"># =&gt; None()</span></pre></div>

<h2>
<a id="either" class="anchor" href="#either" aria-hidden="true"><span class="octicon octicon-link"></span></a>Either</h2>

<p>The Either monad is useful to express a pipeline of computations that might return an error object with some information.</p>

<p>It has two type constructors: <code>Right</code> and <code>Left</code>. As a useful mnemonic, <code>Right</code> is for when everything went "right" and <code>Left</code> is used for errors.</p>

<p>Think of it as exceptions without messing with the call stack.</p>

<h3>
<a id="--bind-2" class="anchor" href="#--bind-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>&gt;-&gt;</code> (bind)</h3>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

result <span class="o">=</span> <span class="no">Right</span>(<span class="m">3</span>) <span class="o">&gt;</span><span class="o">-</span><span class="o">&gt;</span> value {
  <span class="k">if</span> value <span class="o">&gt;</span> <span class="m">1</span>
    <span class="no">Right</span>(value <span class="o">+</span> <span class="m">3</span>)
  <span class="k">else</span>
    <span class="no">Left</span>(<span class="s2">"value was less or equal than 1"</span>)
  <span class="k">end</span>
} <span class="o">&gt;</span><span class="o">-</span><span class="o">&gt;</span> value {
  <span class="k">if</span> value <span class="o">%</span> <span class="m">2</span> <span class="o">==</span> <span class="m">0</span>
    <span class="no">Right</span>(value <span class="o">*</span> <span class="m">2</span>)
  <span class="k">else</span>
    <span class="no">Left</span>(<span class="s2">"value was not even"</span>)
  <span class="k">end</span>
}

<span class="c1"># If everything went well</span>
result <span class="c1"># =&gt; Right(12)</span>
result.value <span class="c1"># =&gt; 12</span>

<span class="c1"># If it failed in the first block</span>
result <span class="c1"># =&gt; Left("value was less or equal than 1")</span>
result.value <span class="c1"># =&gt; "value was less or equal than 1"</span>

<span class="c1"># If it failed in the second block</span>
result <span class="c1"># =&gt; Left("value was not even")</span>
result.value <span class="c1"># =&gt; "value was not even"</span></pre></div>

<h3>
<a id="fmap-2" class="anchor" href="#fmap-2" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fmap</code>
</h3>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

result <span class="o">=</span> <span class="k">if</span> foo <span class="o">&gt;</span> bar
  <span class="no">Right</span>(<span class="m">10</span>)
<span class="k">else</span>
  <span class="no">Left</span>(<span class="s2">"wrong"</span>)
<span class="k">end</span>.fmap { <span class="o">|</span><span class="nv">x</span><span class="o">|</span> x <span class="o">*</span> <span class="m">2</span> }

<span class="c1"># If everything went well</span>
result <span class="c1"># =&gt; Right(20)</span>
<span class="c1"># If it didn't</span>
result <span class="c1"># =&gt; Left("wrong")</span></pre></div>

<h3>
<a id="to_maybe-1" class="anchor" href="#to_maybe-1" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>to_maybe</code>
</h3>

<p>Sometimes it's useful to turn an <code>Either</code> into a <code>Maybe</code>. You can use
<code>to_maybe</code> for that:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

result <span class="o">=</span> <span class="k">if</span> foo <span class="o">&gt;</span> bar
  <span class="no">Right</span>(<span class="m">10</span>)
<span class="k">else</span>
  <span class="no">Left</span>(<span class="s2">"wrong"</span>)
<span class="k">end</span>.to_maybe

<span class="c1"># If everything went well:</span>
result <span class="c1"># =&gt; Some(10)</span>
<span class="c1"># If it didn't</span>
result <span class="c1"># =&gt; None()</span></pre></div>

<h2>
<a id="writer" class="anchor" href="#writer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Writer</h2>

<p>The Writer monad is arguably the least useful monad in Ruby (as side effects
are uncontrolled), but let's take a look at it anyway.</p>

<p>It is used to model computations that <em>append</em> to some kind of state (which
needs to be a Monoid, expressed in the <code>Kleisli::Monoid</code> mixin) at each step.</p>

<p>(We've already implemented the Monoid interface for <code>String</code>, <code>Array</code>, <code>Hash</code>,
<code>Fixnum</code> and <code>Float</code> for you.)</p>

<p>An example would be a pipeline of computations that append to a log, for
example a list of strings.</p>

<h3>
<a id="--bind-3" class="anchor" href="#--bind-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>&gt;-&gt;</code> (bind)</h3>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

writer <span class="o">=</span> <span class="no">Writer</span>(<span class="o">[</span><span class="o">]</span>, <span class="m">100</span>) <span class="o">&gt;</span><span class="o">-</span><span class="o">&gt;</span> value {
  <span class="no">Writer</span>(<span class="o">[</span><span class="s2">"added 100"</span><span class="o">]</span>, value <span class="o">+</span> <span class="m">100</span>)
} <span class="o">&gt;</span><span class="o">-</span><span class="o">&gt;</span> value {
  <span class="no">Writer</span>(<span class="o">[</span><span class="s2">"added 140 more"</span><span class="o">]</span>, value <span class="o">+</span> <span class="m">140</span>)
} <span class="c1"># =&gt; Writer(["added 100", "added 140 more"], 340)</span>

log, value <span class="o">=</span> writer.unwrap
log <span class="c1"># =&gt; ["added 100", "added 140 more"]</span>
value <span class="c1"># =&gt; 340</span></pre></div>

<h3>
<a id="fmap-3" class="anchor" href="#fmap-3" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fmap</code>
</h3>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

writer <span class="o">=</span> <span class="no">Writer</span>(<span class="o">[</span><span class="o">]</span>, <span class="m">100</span>).fmap { <span class="o">|</span><span class="nv">value</span><span class="o">|</span>
  value <span class="o">+</span> <span class="m">100</span>
} <span class="c1"># =&gt; Writer([], 200)</span></pre></div>

<h2>
<a id="future" class="anchor" href="#future" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future</h2>

<p>The Future monad models a pipeline of computations that will happen in the future, as soon as the value needed for each step is available. It is useful to model, for example, a sequential chain of HTTP calls.</p>

<p>There's a catch unfortunately -- values passed to the functions are wrapped in
lambdas, so you need to call <code>.call</code> on them. See the examples below.</p>

<h3>
<a id="--bind-4" class="anchor" href="#--bind-4" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<code>&gt;-&gt;</code> (bind)</h3>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

f <span class="o">=</span> <span class="no">Future</span>(<span class="s2">"myendpoint.com"</span>) <span class="o">&gt;</span><span class="o">-</span><span class="o">&gt;</span> url {
  <span class="no">Future</span> { <span class="no">HTTP</span>.get(url.call) }
} <span class="o">&gt;</span><span class="o">-</span><span class="o">&gt;</span> response {
  <span class="no">Future</span> {
    other_url <span class="o">=</span> <span class="no">JSON</span>.parse(response.call.body)<span class="o">[</span><span class="ss">:other_url</span><span class="o">]</span>
    <span class="no">HTTP</span>.get(other_url)
  }
} <span class="o">&gt;</span><span class="o">-</span><span class="o">&gt;</span> other_response {
  <span class="no">Future</span> { <span class="no">JSON</span>.parse(other_response.call.body) }
}

<span class="c1"># Do some other stuff...</span>

f.await <span class="c1"># =&gt; block until the whole pipeline is realized</span>
<span class="c1"># =&gt; { "my" =&gt; "response body" }</span></pre></div>

<h3>
<a id="fmap-4" class="anchor" href="#fmap-4" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fmap</code>
</h3>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s2">"kleisli"</span>

<span class="no">Future</span> { expensive_operation }.fmap { <span class="o">|</span><span class="nv">x</span><span class="o">|</span> x <span class="o">*</span> <span class="m">2</span> }.await
<span class="c1"># =&gt; result of expensive_operation * 2</span></pre></div>

<h2>
<a id="whos-this" class="anchor" href="#whos-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>Who's this</h2>

<p>This was made by <a href="http://blog.txus.io">Josep M. Bach (Txus)</a> and <a href="https://github.com/rylev">Ryan
Levick</a> under the MIT license. We are <a href="https://twitter.com/txustice">@txustice</a> and
<a href="https://twitter.com/itchyankles">@itchyankles</a> on twitter (where you should probably follow us!).</p>
        </section>

        <footer>
          Kleisli is maintained by <a href="https://github.com/txus">txus</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

                  <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-19362711-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

      </div>
    </div>
  </body>
</html>
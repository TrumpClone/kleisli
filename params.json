{"name":"Kleisli","tagline":"Usable, idiomatic common monads in Ruby","body":"[![Build Status](https://secure.travis-ci.org/txus/kleisli.png)](http://travis-ci.org/txus/kleisli)\r\n\r\nAn idiomatic, clean implementation of a few common useful monads in Ruby,\r\nwritten by [Ryan Levick][rylev] and me.\r\n\r\nIt aims to be idiomatic Ruby to use in Enter-Prise production apps, not a proof\r\nof concept.\r\n\r\nIn your Gemfile:\r\n\r\n```ruby\r\ngem 'kleisli'\r\n```\r\n\r\nWe would like to thank Curry and Howard for their correspondence.\r\n\r\n## Notation\r\n\r\nFor all its monads, Kleisli implements `return` (we call it `lift` instead, as\r\n`return` is a reserved keyword in Ruby) with convenience global methods (see\r\nwhich for each monad below).\r\n\r\nKleisli uses a clever Ruby syntax trick to implement the `bind` operator, which\r\nlooks like this: `>->` when used with a block. We will probably burn in hell\r\nfor this. You can also use `>` or `>>` if you're going to pass in a proc or\r\n lambda object.\r\n\r\n`Maybe` and `Either` are applicative functors with the apply operator `*`. Read\r\nfurther to see how it works.\r\n\r\n### Function composition\r\n\r\nYou can use Haskell-like function composition with F and the familiar `.`. This\r\nis such a perversion of Ruby syntax that Matz would probably condemn this:\r\n\r\nThink of `F` as the identity function. Although it's just a hack to make it\r\nwork in Ruby.\r\n\r\n```ruby\r\n# Reminder that (f . g) x= f(g(x))\r\nf = F . first . last\r\nf.call [[1,2], [3,4]]\r\n# => 3\r\n\r\nf = F . capitalize . reverse\r\nf.call \"hello\"\r\n# => \"Olleh\"\r\n```\r\n\r\nFunctions and methods are interchangeable:\r\n\r\n```ruby\r\nfoo = lambda { |s| s.reverse }\r\n\r\nf = F . capitalize . fn(&foo)\r\nf.call \"hello\"\r\n# => \"Olleh\"\r\n```\r\n\r\nAll functions and methods are partially applicable:\r\n\r\n```ruby\r\n\r\n# Partially applied method:\r\nf = F . split(\":\") . strip\r\nf.call \"  localhost:9092     \"\r\n# => [\"localhost\", \"9092\"]\r\n\r\n# Partially applied lambda:\r\nmy_split = lambda { |str, *args| str.split(*args) }\r\nf = F . fn(\":\", &my_split) . strip\r\nf.call \"  localhost:9092     \"\r\n# => [\"localhost\", \"9092\"]\r\n```\r\n\r\nFinally, for convenience, `F` is the identity function:\r\n\r\n```ruby\r\nF.call(1) # => 1\r\n```\r\n\r\n## Maybe monad\r\n\r\nThe Maybe monad is useful to express a pipeline of computations that might\r\nreturn nil at any point. `user.address.street` anyone?\r\n\r\n### `>->` (bind)\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\nmaybe_user = Maybe(user) >-> user {\r\n  Maybe(user.address) } >-> address {\r\n    Maybe(address.street) }\r\n\r\n# If user exists\r\n# => Some(\"Monad Street\")\r\n# If user is nil\r\n# => None()\r\n\r\n# You can also use Some and None as type constructors yourself.\r\nx = Some(10)\r\ny = None()\r\n\r\n```\r\n\r\nAs usual (with Maybe and Either), using point-free style is much cleaner:\r\n\r\n```ruby\r\nMaybe(user) >> F . fn(&Maybe) . address >> F . fn(&Maybe) . street\r\n```\r\n\r\n### `fmap`\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\n# If we know that a user always has an address with a street\r\nMaybe(user).fmap(&:address).fmap(&:street)\r\n\r\n# If the user exists\r\n# => Some(\"Monad Street\")\r\n# If the user is nil\r\n# => None()\r\n```\r\n\r\n### `*` (applicative functor's apply)\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\nadd = -> x, y { x + y }\r\nSome(add) * Some(10) * Some(2)\r\n# => Some(12)\r\nSome(add) * None() * Some(2)\r\n# => None\r\n```\r\n\r\n## Try\r\n\r\nThe Try monad is useful to express a pipeline of computations that might throw\r\nan exception at any point.\r\n\r\n### `>->` (bind)\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\njson_string = get_json_from_somewhere\r\n\r\nresult = Try { JSON.parse(json_string) } >-> json {\r\n  Try { json[\"dividend\"].to_i / json[\"divisor\"].to_i }\r\n}\r\n\r\n# If no exception was thrown:\r\n\r\nresult       # => #<Try::Success @value=123>\r\nresult.value # => 123\r\n\r\n# If there was a ZeroDivisionError exception for example:\r\n\r\nresult           # => #<Try::Failure @exception=#<ZeroDivisionError ...>>\r\nresult.exception # => #<ZeroDivisionError ...>\r\n```\r\n\r\n### `fmap`\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\nTry { JSON.parse(json_string) }.fmap(&:symbolize_keys).value\r\n\r\n# If everything went well:\r\n# => { :my => \"json\", :with => \"symbolized keys\" }\r\n# If an exception was thrown:\r\n# => nil\r\n```\r\n\r\n### `to_maybe`\r\n\r\nSometimes it's useful to interleave both `Try` and `Maybe`. To convert a `Try`\r\ninto a `Maybe` you can use `to_maybe`:\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\nTry { JSON.parse(json_string) }.fmap(&:symbolize_keys).to_maybe\r\n\r\n# If everything went well:\r\n# => Some({ :my => \"json\", :with => \"symbolized keys\" })\r\n# If an exception was thrown:\r\n# => None()\r\n```\r\n\r\n## Either\r\n\r\nThe Either monad is useful to express a pipeline of computations that might return an error object with some information.\r\n\r\nIt has two type constructors: `Right` and `Left`. As a useful mnemonic, `Right` is for when everything went \"right\" and `Left` is used for errors.\r\n\r\nThink of it as exceptions without messing with the call stack.\r\n\r\n### `>->` (bind)\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\nresult = Right(3) >-> value {\r\n  if value > 1\r\n    Right(value + 3)\r\n  else\r\n    Left(\"value was less or equal than 1\")\r\n  end\r\n} >-> value {\r\n  if value % 2 == 0\r\n    Right(value * 2)\r\n  else\r\n    Left(\"value was not even\")\r\n  end\r\n}\r\n\r\n# If everything went well\r\nresult # => Right(12)\r\nresult.value # => 12\r\n\r\n# If it failed in the first block\r\nresult # => Left(\"value was less or equal than 1\")\r\nresult.value # => \"value was less or equal than 1\"\r\n\r\n# If it failed in the second block\r\nresult # => Left(\"value was not even\")\r\nresult.value # => \"value was not even\"\r\n\r\n# Point-free style bind!\r\nresult = Right(3) >> F . fn(&Right) . *(2)\r\nresult # => Right(6)\r\nresult.value # => 6\r\n```\r\n\r\n### `fmap`\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\nresult = if foo > bar\r\n  Right(10)\r\nelse\r\n  Left(\"wrong\")\r\nend.fmap { |x| x * 2 }\r\n\r\n# If everything went well\r\nresult # => Right(20)\r\n# If it didn't\r\nresult # => Left(\"wrong\")\r\n```\r\n\r\n### `*` (applicative functor's apply)\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\nadd = -> x, y { x + y }\r\nRight(add) * Right(10) * Right(2)\r\n# => Right(12)\r\nRight(add) * Left(\"error\") * Right(2)\r\n# => Left(\"error\")\r\n```\r\n\r\n### `or`\r\n\r\n`or` does pretty much what would you expect:\r\n\r\n```ruby\r\nrequire 'kleisli'\r\n\r\nRight(10).or(Right(999)) # => Right(10)\r\nLeft(\"error\").or(Left(\"new error\")) # => Left(\"new error\")\r\nLeft(\"error\").or { |err| Left(\"new #{err}\") } # => Left(\"new error\")\r\n```\r\n\r\n### `to_maybe`\r\n\r\nSometimes it's useful to turn an `Either` into a `Maybe`. You can use\r\n`to_maybe` for that:\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\nresult = if foo > bar\r\n  Right(10)\r\nelse\r\n  Left(\"wrong\")\r\nend.to_maybe\r\n\r\n# If everything went well:\r\nresult # => Some(10)\r\n# If it didn't\r\nresult # => None()\r\n```\r\n\r\n## Future\r\n\r\nThe Future monad models a pipeline of computations that will happen in the future, as soon as the value needed for each step is available. It is useful to model, for example, a sequential chain of HTTP calls.\r\n\r\nThere's a catch unfortunately -- values passed to the functions are wrapped in\r\nlambdas, so you need to call `.call` on them. See the examples below.\r\n\r\n### `>->` (bind)\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\nf = Future(\"myendpoint.com\") >-> url {\r\n  Future { HTTP.get(url.call) }\r\n} >-> response {\r\n  Future {\r\n    other_url = JSON.parse(response.call.body)[:other_url]\r\n    HTTP.get(other_url)\r\n  }\r\n} >-> other_response {\r\n  Future { JSON.parse(other_response.call.body) }\r\n}\r\n\r\n# Do some other stuff...\r\n\r\nf.await # => block until the whole pipeline is realized\r\n# => { \"my\" => \"response body\" }\r\n```\r\n\r\n### `fmap`\r\n\r\n```ruby\r\nrequire \"kleisli\"\r\n\r\nFuture { expensive_operation }.fmap { |x| x * 2 }.await\r\n# => result of expensive_operation * 2\r\n```\r\n\r\n## Who's this\r\n\r\nThis was made by [Josep M. Bach (Txus)](http://blog.txus.io) and [Ryan\r\nLevick][rylev] under the MIT license. We are [@txustice][twitter] and\r\n[@itchyankles][itchyankles] on twitter (where you should probably follow us!).\r\n\r\n[twitter]: https://twitter.com/txustice\r\n[itchyankles]: https://twitter.com/itchyankles\r\n[rylev]: https://github.com/rylev\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}